// Code generated by MockGen. DO NOT EDIT.
// Source: interfaces.go

// Package mocks is a generated GoMock package.
package iptablerules

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockCommandRunner is a mock of CommandRunner interface.
type MockCommandRunner struct {
	ctrl     *gomock.Controller
	recorder *MockCommandRunnerMockRecorder
}

// MockCommandRunnerMockRecorder is the mock recorder for MockCommandRunner.
type MockCommandRunnerMockRecorder struct {
	mock *MockCommandRunner
}

// NewMockCommandRunner creates a new mock instance.
func NewMockCommandRunner(ctrl *gomock.Controller) *MockCommandRunner {
	mock := &MockCommandRunner{ctrl: ctrl}
	mock.recorder = &MockCommandRunnerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommandRunner) EXPECT() *MockCommandRunnerMockRecorder {
	return m.recorder
}

// Run mocks base method.
func (m *MockCommandRunner) Run(cmd string, args ...string) ([]byte, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{cmd}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Run", varargs...)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Run indicates an expected call of Run.
func (mr *MockCommandRunnerMockRecorder) Run(cmd interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{cmd}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockCommandRunner)(nil).Run), varargs...)
}

// MockIptablesInterface is a mock of IptablesInterface interface.
type MockIptablesInterface struct {
	ctrl     *gomock.Controller
	recorder *MockIptablesInterfaceMockRecorder
}

// MockIptablesInterfaceMockRecorder is the mock recorder for MockIptablesInterface.
type MockIptablesInterfaceMockRecorder struct {
	mock *MockIptablesInterface
}

// NewMockIptablesInterface creates a new mock instance.
func NewMockIptablesInterface(ctrl *gomock.Controller) *MockIptablesInterface {
	mock := &MockIptablesInterface{ctrl: ctrl}
	mock.recorder = &MockIptablesInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIptablesInterface) EXPECT() *MockIptablesInterfaceMockRecorder {
	return m.recorder
}

// ClearChain mocks base method.
func (m *MockIptablesInterface) ClearChain(table, chain string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClearChain", table, chain)
	ret0, _ := ret[0].(error)
	return ret0
}

// ClearChain indicates an expected call of ClearChain.
func (mr *MockIptablesInterfaceMockRecorder) ClearChain(table, chain interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClearChain", reflect.TypeOf((*MockIptablesInterface)(nil).ClearChain), table, chain)
}

// DeleteIfExists mocks base method.
func (m *MockIptablesInterface) DeleteIfExists(table, chain string, rulespec ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{table, chain}
	for _, a := range rulespec {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteIfExists", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteIfExists indicates an expected call of DeleteIfExists.
func (mr *MockIptablesInterfaceMockRecorder) DeleteIfExists(table, chain interface{}, rulespec ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{table, chain}, rulespec...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteIfExists", reflect.TypeOf((*MockIptablesInterface)(nil).DeleteIfExists), varargs...)
}

// InsertUnique mocks base method.
func (m *MockIptablesInterface) InsertUnique(table, chain string, pos int, rulespec ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{table, chain, pos}
	for _, a := range rulespec {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertUnique", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertUnique indicates an expected call of InsertUnique.
func (mr *MockIptablesInterfaceMockRecorder) InsertUnique(table, chain, pos interface{}, rulespec ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{table, chain, pos}, rulespec...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertUnique", reflect.TypeOf((*MockIptablesInterface)(nil).InsertUnique), varargs...)
}

// List mocks base method.
func (m *MockIptablesInterface) List(table, chain string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List", table, chain)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// List indicates an expected call of List.
func (mr *MockIptablesInterfaceMockRecorder) List(table, chain interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockIptablesInterface)(nil).List), table, chain)
}

// MockIptablesManager is a mock of IptablesManager interface.
type MockIptablesManager struct {
	ctrl     *gomock.Controller
	recorder *MockIptablesManagerMockRecorder
}

// MockIptablesManagerMockRecorder is the mock recorder for MockIptablesManager.
type MockIptablesManagerMockRecorder struct {
	mock *MockIptablesManager
}

// NewMockIptablesManager creates a new mock instance.
func NewMockIptablesManager(ctrl *gomock.Controller) *MockIptablesManager {
	mock := &MockIptablesManager{ctrl: ctrl}
	mock.recorder = &MockIptablesManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIptablesManager) EXPECT() *MockIptablesManagerMockRecorder {
	return m.recorder
}

// FlushForward mocks base method.
func (m *MockIptablesManager) FlushForward() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FlushForward")
	ret0, _ := ret[0].(error)
	return ret0
}

// FlushForward indicates an expected call of FlushForward.
func (mr *MockIptablesManagerMockRecorder) FlushForward() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlushForward", reflect.TypeOf((*MockIptablesManager)(nil).FlushForward))
}

// GetForwardList mocks base method.
func (m *MockIptablesManager) GetForwardList() ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetForwardList")
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetForwardList indicates an expected call of GetForwardList.
func (mr *MockIptablesManagerMockRecorder) GetForwardList() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetForwardList", reflect.TypeOf((*MockIptablesManager)(nil).GetForwardList))
}

// GetMasqueradeList mocks base method.
func (m *MockIptablesManager) GetMasqueradeList() ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMasqueradeList")
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMasqueradeList indicates an expected call of GetMasqueradeList.
func (mr *MockIptablesManagerMockRecorder) GetMasqueradeList() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMasqueradeList", reflect.TypeOf((*MockIptablesManager)(nil).GetMasqueradeList))
}

// SetForward mocks base method.
func (m *MockIptablesManager) SetForward(position int, port, action, command, source, destination, protocol, comment string, except bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetForward", position, port, action, command, source, destination, protocol, comment, except)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetForward indicates an expected call of SetForward.
func (mr *MockIptablesManagerMockRecorder) SetForward(position, port, action, command, source, destination, protocol, comment, except interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetForward", reflect.TypeOf((*MockIptablesManager)(nil).SetForward), position, port, action, command, source, destination, protocol, comment, except)
}

// SetForwardList mocks base method.
func (m *MockIptablesManager) SetForwardList(position int, port, action, command, source, destination, protocol, comment string, except bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetForwardList", position, port, action, command, source, destination, protocol, comment, except)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetForwardList indicates an expected call of SetForwardList.
func (mr *MockIptablesManagerMockRecorder) SetForwardList(position, port, action, command, source, destination, protocol, comment, except interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetForwardList", reflect.TypeOf((*MockIptablesManager)(nil).SetForwardList), position, port, action, command, source, destination, protocol, comment, except)
}

// SetMasquerade mocks base method.
func (m *MockIptablesManager) SetMasquerade(command, subnet, ifname, comment string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetMasquerade", command, subnet, ifname, comment)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetMasquerade indicates an expected call of SetMasquerade.
func (mr *MockIptablesManagerMockRecorder) SetMasquerade(command, subnet, ifname, comment interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetMasquerade", reflect.TypeOf((*MockIptablesManager)(nil).SetMasquerade), command, subnet, ifname, comment)
}
